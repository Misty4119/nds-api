// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "nds/projection/projection.proto" (package "nds.projection", syntax proto3)
// tslint:disable
//
// [Module] NDS Protocol
// [Component] projection.proto
// [Layer] Contract (language-agnostic)
// [Index] NDS-PROTO-PROJECTION-000
// [Semantic] Projection contract (derived state views optimized for queries).
// [Constraint] Projections are derived and rebuildable from the event stream.
// [Since] 2.0.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../google/protobuf/any";
import { Timestamp } from "../../google/protobuf/timestamp";
// ============================================================================
// [Index] NDS-PROTO-PROJECTION-010 ProjectionId
// ============================================================================

/**
 * [Semantic] Unique identifier for a projection.
 *
 * @generated from protobuf message nds.projection.ProjectionId
 */
export interface ProjectionId {
    /**
     * Projection name (e.g. "balance", "transaction_history").
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Projection version (for versioned projection definitions).
     *
     * @generated from protobuf field: int32 version = 2
     */
    version: number;
}
// ============================================================================
// [Index] NDS-PROTO-PROJECTION-030 NdsProjection
// ============================================================================

/**
 * [Semantic] Derived view aggregated from the event stream.
 * [Behavior] Projections are rebuildable and can be recomputed at any time.
 * [SearchTag] projection, derived-state, replay, query-optimization
 *
 * @generated from protobuf message nds.projection.NdsProjection
 */
export interface NdsProjection {
    /**
     * Projection ID.
     *
     * @generated from protobuf field: nds.projection.ProjectionId id = 1
     */
    id?: ProjectionId;
    /**
     * Projection status.
     *
     * @generated from protobuf field: nds.projection.ProjectionStatus status = 2
     */
    status: ProjectionStatus;
    /**
     * Last processed event ID.
     *
     * @generated from protobuf field: string last_event_id = 3
     */
    lastEventId: string;
    /**
     * Last updated time.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 4
     */
    lastUpdated?: Timestamp;
    /**
     * Projection data (uses Any to support arbitrary types).
     *
     * @generated from protobuf field: google.protobuf.Any data = 5
     */
    data?: Any;
    /**
     * Projection metadata.
     *
     * @generated from protobuf field: map<string, string> metadata = 6
     */
    metadata: {
        [key: string]: string;
    };
}
// ============================================================================
// [Index] NDS-PROTO-PROJECTION-100 Projection Payload Messages
// ============================================================================

/**
 * [Index] NDS-PROTO-PROJECTION-110 BalanceProjection
 * [Semantic] Specialized projection payload for balances.
 *
 * @generated from protobuf message nds.projection.BalanceProjection
 */
export interface BalanceProjection {
    /**
     * Balance value (string representation of a decimal).
     *
     * @generated from protobuf field: string balance = 1
     */
    balance: string;
    /**
     * Asset ID.
     *
     * @generated from protobuf field: string asset_id = 2
     */
    assetId: string;
    /**
     * Owner identity ID.
     *
     * @generated from protobuf field: string owner_id = 3
     */
    ownerId: string;
    /**
     * Last updated time.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 4
     */
    lastUpdated?: Timestamp;
}
/**
 * [Index] NDS-PROTO-PROJECTION-120 LeaderboardEntry
 *
 * @generated from protobuf message nds.projection.LeaderboardEntry
 */
export interface LeaderboardEntry {
    /**
     * Rank.
     *
     * @generated from protobuf field: int32 rank = 1
     */
    rank: number;
    /**
     * Identity ID.
     *
     * @generated from protobuf field: string identity_id = 2
     */
    identityId: string;
    /**
     * Value.
     *
     * @generated from protobuf field: string value = 3
     */
    value: string;
    /**
     * Extra metadata.
     *
     * @generated from protobuf field: map<string, string> metadata = 4
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * [Index] NDS-PROTO-PROJECTION-130 LeaderboardProjection
 *
 * @generated from protobuf message nds.projection.LeaderboardProjection
 */
export interface LeaderboardProjection {
    /**
     * Leaderboard name.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Asset ID.
     *
     * @generated from protobuf field: string asset_id = 2
     */
    assetId: string;
    /**
     * Entries.
     *
     * @generated from protobuf field: repeated nds.projection.LeaderboardEntry entries = 3
     */
    entries: LeaderboardEntry[];
    /**
     * Last updated time.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 4
     */
    lastUpdated?: Timestamp;
}
// ============================================================================
// [Index] NDS-PROTO-PROJECTION-020 ProjectionStatus
// ============================================================================

/**
 * [Semantic] Projection lifecycle status.
 *
 * @generated from protobuf enum nds.projection.ProjectionStatus
 */
export enum ProjectionStatus {
    /**
     * Unspecified.
     *
     * @generated from protobuf enum value: PROJECTION_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Active.
     *
     * @generated from protobuf enum value: PROJECTION_STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * Rebuilding.
     *
     * @generated from protobuf enum value: PROJECTION_STATUS_REBUILDING = 2;
     */
    REBUILDING = 2,
    /**
     * Disabled.
     *
     * @generated from protobuf enum value: PROJECTION_STATUS_DISABLED = 3;
     */
    DISABLED = 3,
    /**
     * Error.
     *
     * @generated from protobuf enum value: PROJECTION_STATUS_ERROR = 4;
     */
    ERROR = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class ProjectionId$Type extends MessageType<ProjectionId> {
    constructor() {
        super("nds.projection.ProjectionId", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProjectionId>): ProjectionId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = 0;
        if (value !== undefined)
            reflectionMergePartial<ProjectionId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProjectionId): ProjectionId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 version */ 2:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProjectionId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 version = 2; */
        if (message.version !== 0)
            writer.tag(2, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.projection.ProjectionId
 */
export const ProjectionId = new ProjectionId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NdsProjection$Type extends MessageType<NdsProjection> {
    constructor() {
        super("nds.projection.NdsProjection", [
            { no: 1, name: "id", kind: "message", T: () => ProjectionId },
            { no: 2, name: "status", kind: "enum", T: () => ["nds.projection.ProjectionStatus", ProjectionStatus, "PROJECTION_STATUS_"] },
            { no: 3, name: "last_event_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 5, name: "data", kind: "message", T: () => Any },
            { no: 6, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<NdsProjection>): NdsProjection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.lastEventId = "";
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<NdsProjection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NdsProjection): NdsProjection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nds.projection.ProjectionId id */ 1:
                    message.id = ProjectionId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* nds.projection.ProjectionStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string last_event_id */ 3:
                    message.lastEventId = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 4:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* google.protobuf.Any data */ 5:
                    message.data = Any.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* map<string, string> metadata */ 6:
                    this.binaryReadMap6(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: NdsProjection["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NdsProjection["metadata"] | undefined, val: NdsProjection["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for nds.projection.NdsProjection.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: NdsProjection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nds.projection.ProjectionId id = 1; */
        if (message.id)
            ProjectionId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* nds.projection.ProjectionStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string last_event_id = 3; */
        if (message.lastEventId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastEventId);
        /* google.protobuf.Timestamp last_updated = 4; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any data = 5; */
        if (message.data)
            Any.internalBinaryWrite(message.data, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 6; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.projection.NdsProjection
 */
export const NdsProjection = new NdsProjection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceProjection$Type extends MessageType<BalanceProjection> {
    constructor() {
        super("nds.projection.BalanceProjection", [
            { no: 1, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "asset_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<BalanceProjection>): BalanceProjection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balance = "";
        message.assetId = "";
        message.ownerId = "";
        if (value !== undefined)
            reflectionMergePartial<BalanceProjection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceProjection): BalanceProjection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string balance */ 1:
                    message.balance = reader.string();
                    break;
                case /* string asset_id */ 2:
                    message.assetId = reader.string();
                    break;
                case /* string owner_id */ 3:
                    message.ownerId = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 4:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceProjection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string balance = 1; */
        if (message.balance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.balance);
        /* string asset_id = 2; */
        if (message.assetId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.assetId);
        /* string owner_id = 3; */
        if (message.ownerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ownerId);
        /* google.protobuf.Timestamp last_updated = 4; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.projection.BalanceProjection
 */
export const BalanceProjection = new BalanceProjection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEntry$Type extends MessageType<LeaderboardEntry> {
    constructor() {
        super("nds.projection.LeaderboardEntry", [
            { no: 1, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "identity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEntry>): LeaderboardEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rank = 0;
        message.identityId = "";
        message.value = "";
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEntry): LeaderboardEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 rank */ 1:
                    message.rank = reader.int32();
                    break;
                case /* string identity_id */ 2:
                    message.identityId = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: LeaderboardEntry["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LeaderboardEntry["metadata"] | undefined, val: LeaderboardEntry["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for nds.projection.LeaderboardEntry.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: LeaderboardEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 rank = 1; */
        if (message.rank !== 0)
            writer.tag(1, WireType.Varint).int32(message.rank);
        /* string identity_id = 2; */
        if (message.identityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.identityId);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        /* map<string, string> metadata = 4; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.projection.LeaderboardEntry
 */
export const LeaderboardEntry = new LeaderboardEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardProjection$Type extends MessageType<LeaderboardProjection> {
    constructor() {
        super("nds.projection.LeaderboardProjection", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "asset_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardEntry },
            { no: 4, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<LeaderboardProjection>): LeaderboardProjection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.assetId = "";
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<LeaderboardProjection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardProjection): LeaderboardProjection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string asset_id */ 2:
                    message.assetId = reader.string();
                    break;
                case /* repeated nds.projection.LeaderboardEntry entries */ 3:
                    message.entries.push(LeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp last_updated */ 4:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardProjection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string asset_id = 2; */
        if (message.assetId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.assetId);
        /* repeated nds.projection.LeaderboardEntry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            LeaderboardEntry.internalBinaryWrite(message.entries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 4; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.projection.LeaderboardProjection
 */
export const LeaderboardProjection = new LeaderboardProjection$Type();
