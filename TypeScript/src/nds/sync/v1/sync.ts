// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "nds/sync/v1/sync.proto" (package "nds.sync.v1", syntax proto3)
// tslint:disable
//
// [Module] NDS Protocol
// [Component] sync.proto
// [Layer] Contract (language-agnostic)
// [Index] NDS-PROTO-SYNC-V1-000
// [Semantic] v3+ streaming semantics: subscribe/replay/resume/backpressure.
// [Since] 3.0.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Money } from "../../ledger/v1/ledger";
import { Cursor } from "../../event/v1/event_v1";
import { Balance } from "../../ledger/v1/ledger";
import { BalanceKey } from "../../ledger/v1/ledger";
import { ErrorStatus } from "../../common/v1/common_v1";
import { EventEnvelope } from "../../event/v1/event_v1";
import { PersonaId } from "../../identity/v1/identity_v1";
import { EventType } from "../../event/v1/event_v1";
import { Timestamp } from "../../../google/protobuf/timestamp";
// ============================================================================
// [Index] NDS-PROTO-SYNC-V1-010 ResumeToken
// ============================================================================

/**
 * [Semantic] Server-issued resume token for continuation.
 * [Invariant] Clients MUST treat this as opaque.
 *
 * @generated from protobuf message nds.sync.v1.ResumeToken
 */
export interface ResumeToken {
    /**
     * @generated from protobuf field: bytes value = 1
     */
    value: Uint8Array;
}
// ============================================================================
// [Index] NDS-PROTO-SYNC-V1-020 SubscribeEvents
// ============================================================================

/**
 * @generated from protobuf message nds.sync.v1.SubscribeEventsRequest
 */
export interface SubscribeEventsRequest {
    /**
     * Resume streaming from a previous position.
     *
     * @generated from protobuf field: optional nds.sync.v1.ResumeToken resume = 1
     */
    resume?: ResumeToken;
    /**
     * Fallback start time (UTC). Used when resume is absent/expired.
     *
     * @generated from protobuf field: optional google.protobuf.Timestamp since = 2
     */
    since?: Timestamp;
    /**
     * Filter by event types.
     *
     * @generated from protobuf field: repeated nds.event.v1.EventType types = 3
     */
    types: EventType[];
    /**
     * Filter by owner persona.
     *
     * @generated from protobuf field: optional nds.identity.v1.PersonaId owner = 4
     */
    owner?: PersonaId;
    /**
     * Flow control hint (best-effort).
     *
     * @generated from protobuf field: int32 max_events_per_second = 10
     */
    maxEventsPerSecond: number;
    /**
     * Flow control hint: maximum number of in-flight messages the client can process.
     *
     * @generated from protobuf field: optional int32 max_in_flight = 11
     */
    maxInFlight?: number;
    /**
     * Flow control hint: preferred batch/page size (for transports that support batching).
     *
     * @generated from protobuf field: optional int32 page_size = 12
     */
    pageSize?: number;
}
/**
 * [Semantic] Subscribe response envelope for streaming transports.
 * [Note] This is a shape definition; transports (gRPC/WebSocket/etc.) are implementation-defined.
 *
 * @generated from protobuf message nds.sync.v1.SubscribeEventsResponse
 */
export interface SubscribeEventsResponse {
    /**
     * Server-issued resume token representing the last delivered position.
     * Implementations SHOULD update this as events are delivered.
     *
     * @generated from protobuf field: optional nds.sync.v1.ResumeToken resume = 1
     */
    resume?: ResumeToken;
    /**
     * Ordering guarantee of this stream.
     *
     * @generated from protobuf field: optional nds.sync.v1.OrderingMode ordering = 2
     */
    ordering?: OrderingMode;
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "event";
        /**
         * A single event delivery.
         *
         * @generated from protobuf field: nds.event.v1.EventEnvelope event = 10
         */
        event: EventEnvelope;
    } | {
        oneofKind: "heartbeat";
        /**
         * A non-fatal heartbeat to keep the stream alive.
         *
         * @generated from protobuf field: nds.sync.v1.Heartbeat heartbeat = 11
         */
        heartbeat: Heartbeat;
    } | {
        oneofKind: "error";
        /**
         * Terminal or retryable error. See nds.common.v1.ErrorCategory for retry decisions.
         *
         * @generated from protobuf field: nds.common.v1.ErrorStatus error = 12
         */
        error: ErrorStatus;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message nds.sync.v1.Heartbeat
 */
export interface Heartbeat {
    /**
     * Server time (UTC) when heartbeat was emitted.
     *
     * @generated from protobuf field: optional google.protobuf.Timestamp at = 1
     */
    at?: Timestamp;
}
// ============================================================================
// [Index] NDS-PROTO-SYNC-V1-030 WatchBalance
// ============================================================================

/**
 * @generated from protobuf message nds.sync.v1.WatchBalanceRequest
 */
export interface WatchBalanceRequest {
    /**
     * @generated from protobuf field: nds.ledger.v1.BalanceKey key = 1
     */
    key?: BalanceKey;
    /**
     * @generated from protobuf field: optional nds.sync.v1.ResumeToken resume = 2
     */
    resume?: ResumeToken;
    /**
     * Flow control hint (best-effort).
     *
     * @generated from protobuf field: int32 max_updates_per_second = 10
     */
    maxUpdatesPerSecond: number;
    /**
     * @generated from protobuf field: optional int32 max_in_flight = 11
     */
    maxInFlight?: number;
}
/**
 * @generated from protobuf message nds.sync.v1.BalanceSnapshot
 */
export interface BalanceSnapshot {
    /**
     * @generated from protobuf field: nds.ledger.v1.Balance balance = 1
     */
    balance?: Balance;
    /**
     * @generated from protobuf field: nds.event.v1.Cursor cursor = 2
     */
    cursor?: Cursor;
}
/**
 * [Semantic] Delta update (preferred over full-state push).
 *
 * @generated from protobuf message nds.sync.v1.BalanceDelta
 */
export interface BalanceDelta {
    /**
     * @generated from protobuf field: nds.ledger.v1.BalanceKey key = 1
     */
    key?: BalanceKey;
    /**
     * @generated from protobuf field: nds.ledger.v1.Money delta = 2
     */
    delta?: Money;
    /**
     * @generated from protobuf field: uint64 new_version = 3
     */
    newVersion: string;
    /**
     * @generated from protobuf field: nds.event.v1.Cursor cursor = 4
     */
    cursor?: Cursor;
    /**
     * Proof link to the committed transaction.
     *
     * @generated from protobuf field: bytes proof_tx_id = 5
     */
    proofTxId: Uint8Array;
    /**
     * Optional proof link to the committed event (if event id differs from tx id).
     *
     * @generated from protobuf field: optional bytes proof_event_id = 6
     */
    proofEventId?: Uint8Array;
}
/**
 * [Semantic] Watch response envelope for streaming transports.
 *
 * @generated from protobuf message nds.sync.v1.WatchBalanceResponse
 */
export interface WatchBalanceResponse {
    /**
     * @generated from protobuf field: optional nds.sync.v1.ResumeToken resume = 1
     */
    resume?: ResumeToken;
    /**
     * @generated from protobuf field: optional nds.sync.v1.OrderingMode ordering = 2
     */
    ordering?: OrderingMode;
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "snapshot";
        /**
         * @generated from protobuf field: nds.sync.v1.BalanceSnapshot snapshot = 10
         */
        snapshot: BalanceSnapshot;
    } | {
        oneofKind: "delta";
        /**
         * @generated from protobuf field: nds.sync.v1.BalanceDelta delta = 11
         */
        delta: BalanceDelta;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: nds.common.v1.ErrorStatus error = 12
         */
        error: ErrorStatus;
    } | {
        oneofKind: "heartbeat";
        /**
         * @generated from protobuf field: nds.sync.v1.Heartbeat heartbeat = 13
         */
        heartbeat: Heartbeat;
    } | {
        oneofKind: undefined;
    };
}
// ============================================================================
// [Index] NDS-PROTO-SYNC-V1-015 OrderingMode
// ============================================================================

/**
 * [Semantic] Declares the ordering guarantee of a stream.
 *
 * @generated from protobuf enum nds.sync.v1.OrderingMode
 */
export enum OrderingMode {
    /**
     * @generated from protobuf enum value: ORDERING_MODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * A single stream has a total order; cursor is monotonically increasing.
     *
     * @generated from protobuf enum value: ORDERING_MODE_TOTAL = 1;
     */
    TOTAL = 1,
    /**
     * Ordering is guaranteed only within a partition (e.g. per owner/key).
     *
     * @generated from protobuf enum value: ORDERING_MODE_PARTITIONED = 2;
     */
    PARTITIONED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ResumeToken$Type extends MessageType<ResumeToken> {
    constructor() {
        super("nds.sync.v1.ResumeToken", [
            { no: 1, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResumeToken>): ResumeToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResumeToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResumeToken): ResumeToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes value */ 1:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResumeToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes value = 1; */
        if (message.value.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.ResumeToken
 */
export const ResumeToken = new ResumeToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor() {
        super("nds.sync.v1.SubscribeEventsRequest", [
            { no: 1, name: "resume", kind: "message", T: () => ResumeToken },
            { no: 2, name: "since", kind: "message", T: () => Timestamp },
            { no: 3, name: "types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["nds.event.v1.EventType", EventType, "EVENT_TYPE_"] },
            { no: 4, name: "owner", kind: "message", T: () => PersonaId },
            { no: 10, name: "max_events_per_second", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "max_in_flight", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "page_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        message.maxEventsPerSecond = 0;
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional nds.sync.v1.ResumeToken resume */ 1:
                    message.resume = ResumeToken.internalBinaryRead(reader, reader.uint32(), options, message.resume);
                    break;
                case /* optional google.protobuf.Timestamp since */ 2:
                    message.since = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.since);
                    break;
                case /* repeated nds.event.v1.EventType types */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                case /* optional nds.identity.v1.PersonaId owner */ 4:
                    message.owner = PersonaId.internalBinaryRead(reader, reader.uint32(), options, message.owner);
                    break;
                case /* int32 max_events_per_second */ 10:
                    message.maxEventsPerSecond = reader.int32();
                    break;
                case /* optional int32 max_in_flight */ 11:
                    message.maxInFlight = reader.int32();
                    break;
                case /* optional int32 page_size */ 12:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional nds.sync.v1.ResumeToken resume = 1; */
        if (message.resume)
            ResumeToken.internalBinaryWrite(message.resume, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp since = 2; */
        if (message.since)
            Timestamp.internalBinaryWrite(message.since, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated nds.event.v1.EventType types = 3; */
        if (message.types.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        /* optional nds.identity.v1.PersonaId owner = 4; */
        if (message.owner)
            PersonaId.internalBinaryWrite(message.owner, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 max_events_per_second = 10; */
        if (message.maxEventsPerSecond !== 0)
            writer.tag(10, WireType.Varint).int32(message.maxEventsPerSecond);
        /* optional int32 max_in_flight = 11; */
        if (message.maxInFlight !== undefined)
            writer.tag(11, WireType.Varint).int32(message.maxInFlight);
        /* optional int32 page_size = 12; */
        if (message.pageSize !== undefined)
            writer.tag(12, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.SubscribeEventsRequest
 */
export const SubscribeEventsRequest = new SubscribeEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor() {
        super("nds.sync.v1.SubscribeEventsResponse", [
            { no: 1, name: "resume", kind: "message", T: () => ResumeToken },
            { no: 2, name: "ordering", kind: "enum", opt: true, T: () => ["nds.sync.v1.OrderingMode", OrderingMode, "ORDERING_MODE_"] },
            { no: 10, name: "event", kind: "message", oneof: "message", T: () => EventEnvelope },
            { no: 11, name: "heartbeat", kind: "message", oneof: "message", T: () => Heartbeat },
            { no: 12, name: "error", kind: "message", oneof: "message", T: () => ErrorStatus }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional nds.sync.v1.ResumeToken resume */ 1:
                    message.resume = ResumeToken.internalBinaryRead(reader, reader.uint32(), options, message.resume);
                    break;
                case /* optional nds.sync.v1.OrderingMode ordering */ 2:
                    message.ordering = reader.int32();
                    break;
                case /* nds.event.v1.EventEnvelope event */ 10:
                    message.message = {
                        oneofKind: "event",
                        event: EventEnvelope.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).event)
                    };
                    break;
                case /* nds.sync.v1.Heartbeat heartbeat */ 11:
                    message.message = {
                        oneofKind: "heartbeat",
                        heartbeat: Heartbeat.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).heartbeat)
                    };
                    break;
                case /* nds.common.v1.ErrorStatus error */ 12:
                    message.message = {
                        oneofKind: "error",
                        error: ErrorStatus.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional nds.sync.v1.ResumeToken resume = 1; */
        if (message.resume)
            ResumeToken.internalBinaryWrite(message.resume, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.sync.v1.OrderingMode ordering = 2; */
        if (message.ordering !== undefined)
            writer.tag(2, WireType.Varint).int32(message.ordering);
        /* nds.event.v1.EventEnvelope event = 10; */
        if (message.message.oneofKind === "event")
            EventEnvelope.internalBinaryWrite(message.message.event, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* nds.sync.v1.Heartbeat heartbeat = 11; */
        if (message.message.oneofKind === "heartbeat")
            Heartbeat.internalBinaryWrite(message.message.heartbeat, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* nds.common.v1.ErrorStatus error = 12; */
        if (message.message.oneofKind === "error")
            ErrorStatus.internalBinaryWrite(message.message.error, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.SubscribeEventsResponse
 */
export const SubscribeEventsResponse = new SubscribeEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Heartbeat$Type extends MessageType<Heartbeat> {
    constructor() {
        super("nds.sync.v1.Heartbeat", [
            { no: 1, name: "at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Heartbeat>): Heartbeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Heartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heartbeat): Heartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp at */ 1:
                    message.at = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.at);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp at = 1; */
        if (message.at)
            Timestamp.internalBinaryWrite(message.at, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.Heartbeat
 */
export const Heartbeat = new Heartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchBalanceRequest$Type extends MessageType<WatchBalanceRequest> {
    constructor() {
        super("nds.sync.v1.WatchBalanceRequest", [
            { no: 1, name: "key", kind: "message", T: () => BalanceKey },
            { no: 2, name: "resume", kind: "message", T: () => ResumeToken },
            { no: 10, name: "max_updates_per_second", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "max_in_flight", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WatchBalanceRequest>): WatchBalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxUpdatesPerSecond = 0;
        if (value !== undefined)
            reflectionMergePartial<WatchBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchBalanceRequest): WatchBalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nds.ledger.v1.BalanceKey key */ 1:
                    message.key = BalanceKey.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* optional nds.sync.v1.ResumeToken resume */ 2:
                    message.resume = ResumeToken.internalBinaryRead(reader, reader.uint32(), options, message.resume);
                    break;
                case /* int32 max_updates_per_second */ 10:
                    message.maxUpdatesPerSecond = reader.int32();
                    break;
                case /* optional int32 max_in_flight */ 11:
                    message.maxInFlight = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nds.ledger.v1.BalanceKey key = 1; */
        if (message.key)
            BalanceKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.sync.v1.ResumeToken resume = 2; */
        if (message.resume)
            ResumeToken.internalBinaryWrite(message.resume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 max_updates_per_second = 10; */
        if (message.maxUpdatesPerSecond !== 0)
            writer.tag(10, WireType.Varint).int32(message.maxUpdatesPerSecond);
        /* optional int32 max_in_flight = 11; */
        if (message.maxInFlight !== undefined)
            writer.tag(11, WireType.Varint).int32(message.maxInFlight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.WatchBalanceRequest
 */
export const WatchBalanceRequest = new WatchBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceSnapshot$Type extends MessageType<BalanceSnapshot> {
    constructor() {
        super("nds.sync.v1.BalanceSnapshot", [
            { no: 1, name: "balance", kind: "message", T: () => Balance },
            { no: 2, name: "cursor", kind: "message", T: () => Cursor }
        ]);
    }
    create(value?: PartialMessage<BalanceSnapshot>): BalanceSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BalanceSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceSnapshot): BalanceSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nds.ledger.v1.Balance balance */ 1:
                    message.balance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* nds.event.v1.Cursor cursor */ 2:
                    message.cursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nds.ledger.v1.Balance balance = 1; */
        if (message.balance)
            Balance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* nds.event.v1.Cursor cursor = 2; */
        if (message.cursor)
            Cursor.internalBinaryWrite(message.cursor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.BalanceSnapshot
 */
export const BalanceSnapshot = new BalanceSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceDelta$Type extends MessageType<BalanceDelta> {
    constructor() {
        super("nds.sync.v1.BalanceDelta", [
            { no: 1, name: "key", kind: "message", T: () => BalanceKey },
            { no: 2, name: "delta", kind: "message", T: () => Money },
            { no: 3, name: "new_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "cursor", kind: "message", T: () => Cursor },
            { no: 5, name: "proof_tx_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "proof_event_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BalanceDelta>): BalanceDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newVersion = "0";
        message.proofTxId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<BalanceDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceDelta): BalanceDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nds.ledger.v1.BalanceKey key */ 1:
                    message.key = BalanceKey.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* nds.ledger.v1.Money delta */ 2:
                    message.delta = Money.internalBinaryRead(reader, reader.uint32(), options, message.delta);
                    break;
                case /* uint64 new_version */ 3:
                    message.newVersion = reader.uint64().toString();
                    break;
                case /* nds.event.v1.Cursor cursor */ 4:
                    message.cursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor);
                    break;
                case /* bytes proof_tx_id */ 5:
                    message.proofTxId = reader.bytes();
                    break;
                case /* optional bytes proof_event_id */ 6:
                    message.proofEventId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nds.ledger.v1.BalanceKey key = 1; */
        if (message.key)
            BalanceKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* nds.ledger.v1.Money delta = 2; */
        if (message.delta)
            Money.internalBinaryWrite(message.delta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 new_version = 3; */
        if (message.newVersion !== "0")
            writer.tag(3, WireType.Varint).uint64(message.newVersion);
        /* nds.event.v1.Cursor cursor = 4; */
        if (message.cursor)
            Cursor.internalBinaryWrite(message.cursor, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof_tx_id = 5; */
        if (message.proofTxId.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.proofTxId);
        /* optional bytes proof_event_id = 6; */
        if (message.proofEventId !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.proofEventId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.BalanceDelta
 */
export const BalanceDelta = new BalanceDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchBalanceResponse$Type extends MessageType<WatchBalanceResponse> {
    constructor() {
        super("nds.sync.v1.WatchBalanceResponse", [
            { no: 1, name: "resume", kind: "message", T: () => ResumeToken },
            { no: 2, name: "ordering", kind: "enum", opt: true, T: () => ["nds.sync.v1.OrderingMode", OrderingMode, "ORDERING_MODE_"] },
            { no: 10, name: "snapshot", kind: "message", oneof: "message", T: () => BalanceSnapshot },
            { no: 11, name: "delta", kind: "message", oneof: "message", T: () => BalanceDelta },
            { no: 12, name: "error", kind: "message", oneof: "message", T: () => ErrorStatus },
            { no: 13, name: "heartbeat", kind: "message", oneof: "message", T: () => Heartbeat }
        ]);
    }
    create(value?: PartialMessage<WatchBalanceResponse>): WatchBalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WatchBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchBalanceResponse): WatchBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional nds.sync.v1.ResumeToken resume */ 1:
                    message.resume = ResumeToken.internalBinaryRead(reader, reader.uint32(), options, message.resume);
                    break;
                case /* optional nds.sync.v1.OrderingMode ordering */ 2:
                    message.ordering = reader.int32();
                    break;
                case /* nds.sync.v1.BalanceSnapshot snapshot */ 10:
                    message.message = {
                        oneofKind: "snapshot",
                        snapshot: BalanceSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).snapshot)
                    };
                    break;
                case /* nds.sync.v1.BalanceDelta delta */ 11:
                    message.message = {
                        oneofKind: "delta",
                        delta: BalanceDelta.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).delta)
                    };
                    break;
                case /* nds.common.v1.ErrorStatus error */ 12:
                    message.message = {
                        oneofKind: "error",
                        error: ErrorStatus.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).error)
                    };
                    break;
                case /* nds.sync.v1.Heartbeat heartbeat */ 13:
                    message.message = {
                        oneofKind: "heartbeat",
                        heartbeat: Heartbeat.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).heartbeat)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional nds.sync.v1.ResumeToken resume = 1; */
        if (message.resume)
            ResumeToken.internalBinaryWrite(message.resume, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.sync.v1.OrderingMode ordering = 2; */
        if (message.ordering !== undefined)
            writer.tag(2, WireType.Varint).int32(message.ordering);
        /* nds.sync.v1.BalanceSnapshot snapshot = 10; */
        if (message.message.oneofKind === "snapshot")
            BalanceSnapshot.internalBinaryWrite(message.message.snapshot, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* nds.sync.v1.BalanceDelta delta = 11; */
        if (message.message.oneofKind === "delta")
            BalanceDelta.internalBinaryWrite(message.message.delta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* nds.common.v1.ErrorStatus error = 12; */
        if (message.message.oneofKind === "error")
            ErrorStatus.internalBinaryWrite(message.message.error, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* nds.sync.v1.Heartbeat heartbeat = 13; */
        if (message.message.oneofKind === "heartbeat")
            Heartbeat.internalBinaryWrite(message.message.heartbeat, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.sync.v1.WatchBalanceResponse
 */
export const WatchBalanceResponse = new WatchBalanceResponse$Type();
