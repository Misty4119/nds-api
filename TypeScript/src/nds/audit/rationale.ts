// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "nds/audit/rationale.proto" (package "nds.audit", syntax proto3)
// tslint:disable
//
// [Module] NDS Protocol
// [Component] rationale.proto
// [Layer] Contract (language-agnostic)
// [Index] NDS-PROTO-AUDIT-000
// [Semantic] Structured rationale for audit / explainability.
// [Since] 2.2.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EventId } from "../event/event";
import { Decimal } from "../common/common";
// ============================================================================
// [Index] NDS-PROTO-AUDIT-010 NdsRationale
// ============================================================================

/**
 * [Semantic] Lightweight structured rationale (safe to embed).
 * [Behavior] Not a full chain-of-thought; keep it auditable and compact.
 *
 * @generated from protobuf message nds.audit.NdsRationale
 */
export interface NdsRationale {
    /**
     * Who/what produced this rationale (e.g. "rule_engine_v1", "human_admin").
     *
     * @generated from protobuf field: string source = 1
     */
    source: string;
    /**
     * Confidence score in [0,1] encoded as Decimal string (exact, language-neutral).
     *
     * @generated from protobuf field: optional nds.common.Decimal confidence = 2
     */
    confidence?: Decimal;
    /**
     * Short structured steps.
     *
     * @generated from protobuf field: repeated string thought_path = 3
     */
    thoughtPath: string[];
    /**
     * Evidence references (within the same resolvable event space).
     *
     * @generated from protobuf field: repeated nds.event.EventId evidence_event_ids = 4
     */
    evidenceEventIds: EventId[];
    /**
     * Cross-system evidence references (URI-based).
     *
     * @generated from protobuf field: repeated nds.audit.NdsRationaleRef evidence_refs = 8
     */
    evidenceRefs: NdsRationaleRef[];
    /**
     * Optional risk indicator (protocol does not define semantics/range).
     *
     * @generated from protobuf field: optional nds.common.Decimal risk_score = 5
     */
    riskScore?: Decimal;
    /**
     * Extension slot.
     *
     * @generated from protobuf field: map<string, string> metadata = 6
     */
    metadata: {
        [key: string]: string;
    };
}
// ============================================================================
// [Index] NDS-PROTO-AUDIT-020 NdsRationaleRef
// ============================================================================

/**
 * [Semantic] External rationale/evidence reference for heavy payloads.
 *
 * @generated from protobuf message nds.audit.NdsRationaleRef
 */
export interface NdsRationaleRef {
    /**
     * URI (e.g. "https://.../report.json", "ipfs://...", "file://...").
     *
     * @generated from protobuf field: string uri = 1
     */
    uri: string;
    /**
     * Optional content hash (e.g. sha256 hex) for integrity.
     *
     * @generated from protobuf field: optional string hash = 2
     */
    hash?: string;
    /**
     * Optional mime type (e.g. "application/json").
     *
     * @generated from protobuf field: optional string mime_type = 3
     */
    mimeType?: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class NdsRationale$Type extends MessageType<NdsRationale> {
    constructor() {
        super("nds.audit.NdsRationale", [
            { no: 1, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "confidence", kind: "message", T: () => Decimal },
            { no: 3, name: "thought_path", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "evidence_event_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EventId },
            { no: 8, name: "evidence_refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => NdsRationaleRef },
            { no: 5, name: "risk_score", kind: "message", T: () => Decimal },
            { no: 6, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<NdsRationale>): NdsRationale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = "";
        message.thoughtPath = [];
        message.evidenceEventIds = [];
        message.evidenceRefs = [];
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<NdsRationale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NdsRationale): NdsRationale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source */ 1:
                    message.source = reader.string();
                    break;
                case /* optional nds.common.Decimal confidence */ 2:
                    message.confidence = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.confidence);
                    break;
                case /* repeated string thought_path */ 3:
                    message.thoughtPath.push(reader.string());
                    break;
                case /* repeated nds.event.EventId evidence_event_ids */ 4:
                    message.evidenceEventIds.push(EventId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated nds.audit.NdsRationaleRef evidence_refs */ 8:
                    message.evidenceRefs.push(NdsRationaleRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional nds.common.Decimal risk_score */ 5:
                    message.riskScore = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.riskScore);
                    break;
                case /* map<string, string> metadata */ 6:
                    this.binaryReadMap6(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: NdsRationale["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NdsRationale["metadata"] | undefined, val: NdsRationale["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for nds.audit.NdsRationale.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: NdsRationale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source = 1; */
        if (message.source !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source);
        /* optional nds.common.Decimal confidence = 2; */
        if (message.confidence)
            Decimal.internalBinaryWrite(message.confidence, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string thought_path = 3; */
        for (let i = 0; i < message.thoughtPath.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.thoughtPath[i]);
        /* repeated nds.event.EventId evidence_event_ids = 4; */
        for (let i = 0; i < message.evidenceEventIds.length; i++)
            EventId.internalBinaryWrite(message.evidenceEventIds[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.common.Decimal risk_score = 5; */
        if (message.riskScore)
            Decimal.internalBinaryWrite(message.riskScore, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 6; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* repeated nds.audit.NdsRationaleRef evidence_refs = 8; */
        for (let i = 0; i < message.evidenceRefs.length; i++)
            NdsRationaleRef.internalBinaryWrite(message.evidenceRefs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.audit.NdsRationale
 */
export const NdsRationale = new NdsRationale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NdsRationaleRef$Type extends MessageType<NdsRationaleRef> {
    constructor() {
        super("nds.audit.NdsRationaleRef", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hash", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mime_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NdsRationaleRef>): NdsRationaleRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        if (value !== undefined)
            reflectionMergePartial<NdsRationaleRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NdsRationaleRef): NdsRationaleRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* optional string hash */ 2:
                    message.hash = reader.string();
                    break;
                case /* optional string mime_type */ 3:
                    message.mimeType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NdsRationaleRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* optional string hash = 2; */
        if (message.hash !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hash);
        /* optional string mime_type = 3; */
        if (message.mimeType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.mimeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.audit.NdsRationaleRef
 */
export const NdsRationaleRef = new NdsRationaleRef$Type();
