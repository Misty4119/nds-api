// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "nds/event/event.proto" (package "nds.event", syntax proto3)
// tslint:disable
//
// [Module] NDS Protocol
// [Component] event.proto
// [Layer] Contract (language-agnostic)
// [Index] NDS-PROTO-EVENT-000
// [Semantic] Event model contract used for append-only history + replay.
// [Constraint] Events MUST be immutable, serializable, and replayable.
// [Constraint] Payload MUST NOT carry platform-specific / non-serializable objects.
// [Since] 2.0.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { NdsContext } from "../context/context";
import { NdsIdentity } from "../identity/identity";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Struct } from "../../google/protobuf/struct";
// ============================================================================
// [Index] NDS-PROTO-EVENT-020 EventId
// ============================================================================

/**
 * [Semantic] Globally unique identifier for an event.
 *
 * @generated from protobuf message nds.event.EventId
 */
export interface EventId {
    /**
     * ID value (recommended: UUID; alternative: timestamp + randomness).
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
}
// ============================================================================
// [Index] NDS-PROTO-EVENT-030 NdsPayload
// ============================================================================

/**
 * [Semantic] Event payload container.
 * [Constraint] Payload MUST contain only serializable primitives / collections.
 * [Constraint] Core implementations MUST reject payloads that embed platform-specific objects.
 * [Behavior] Payload is represented as `Struct` for JSON-like dynamic structures.
 * [SearchTag] payload, serialization, replay-safety
 *
 * @generated from protobuf message nds.event.NdsPayload
 */
export interface NdsPayload {
    /**
     * Payload data represented as `Struct` (JSON-like).
     *
     * @generated from protobuf field: google.protobuf.Struct data = 1
     */
    data?: Struct;
}
// ============================================================================
// [Index] NDS-PROTO-EVENT-040 NdsEvent
// ============================================================================

/**
 * [Semantic] Immutable historical record of a state change.
 * [Behavior] All state transitions are expressed as events (append-only history).
 * [SearchTag] append-only-events, audit, replay, synchronization
 *
 * @generated from protobuf message nds.event.NdsEvent
 */
export interface NdsEvent {
    /**
     * Event ID (globally unique).
     *
     * @generated from protobuf field: nds.event.EventId id = 1
     */
    id?: EventId;
    /**
     * Occurrence time (UTC).
     *
     * @generated from protobuf field: google.protobuf.Timestamp occurred_at = 2
     */
    occurredAt?: Timestamp;
    /**
     * Actor identity.
     *
     * @generated from protobuf field: nds.identity.NdsIdentity actor = 3
     */
    actor?: NdsIdentity;
    /**
     * Event type.
     *
     * @generated from protobuf field: nds.event.EventType type = 4
     */
    type: EventType;
    /**
     * Event payload.
     *
     * @generated from protobuf field: nds.event.NdsPayload payload = 5
     */
    payload?: NdsPayload;
    /**
     * Schema version (for backward compatibility / migrations).
     *
     * @generated from protobuf field: int32 schema_version = 6
     */
    schemaVersion: number;
    /**
     * Metadata.
     *
     * @generated from protobuf field: map<string, string> metadata = 7
     */
    metadata: {
        [key: string]: string;
    };
    /**
     * Context (optional).
     *
     * @generated from protobuf field: optional nds.context.NdsContext context = 8
     */
    context?: NdsContext;
}
// ============================================================================
// [Index] NDS-PROTO-EVENT-010 EventType
// ============================================================================

/**
 * [Semantic] Standard event type taxonomy.
 *
 * @generated from protobuf enum nds.event.EventType
 */
export enum EventType {
    /**
     * Unknown type (default).
     *
     * @generated from protobuf enum value: EVENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Transaction event (asset delta semantics; see NdsTransaction).
     *
     * @generated from protobuf enum value: EVENT_TYPE_TRANSACTION = 1;
     */
    TRANSACTION = 1,
    /**
     * Asset created.
     *
     * @generated from protobuf enum value: EVENT_TYPE_ASSET_CREATED = 2;
     */
    ASSET_CREATED = 2,
    /**
     * Asset updated.
     *
     * @generated from protobuf enum value: EVENT_TYPE_ASSET_UPDATED = 3;
     */
    ASSET_UPDATED = 3,
    /**
     * Asset deleted.
     *
     * @generated from protobuf enum value: EVENT_TYPE_ASSET_DELETED = 4;
     */
    ASSET_DELETED = 4,
    /**
     * Identity created.
     *
     * @generated from protobuf enum value: EVENT_TYPE_IDENTITY_CREATED = 5;
     */
    IDENTITY_CREATED = 5,
    /**
     * Identity updated.
     *
     * @generated from protobuf enum value: EVENT_TYPE_IDENTITY_UPDATED = 6;
     */
    IDENTITY_UPDATED = 6,
    /**
     * System event.
     *
     * @generated from protobuf enum value: EVENT_TYPE_SYSTEM = 7;
     */
    SYSTEM = 7,
    /**
     * Custom event (extension point).
     *
     * @generated from protobuf enum value: EVENT_TYPE_CUSTOM = 99;
     */
    CUSTOM = 99
}
// @generated message type with reflection information, may provide speed optimized methods
class EventId$Type extends MessageType<EventId> {
    constructor() {
        super("nds.event.EventId", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventId>): EventId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<EventId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventId): EventId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.event.EventId
 */
export const EventId = new EventId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NdsPayload$Type extends MessageType<NdsPayload> {
    constructor() {
        super("nds.event.NdsPayload", [
            { no: 1, name: "data", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<NdsPayload>): NdsPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NdsPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NdsPayload): NdsPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct data */ 1:
                    message.data = Struct.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NdsPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct data = 1; */
        if (message.data)
            Struct.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.event.NdsPayload
 */
export const NdsPayload = new NdsPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NdsEvent$Type extends MessageType<NdsEvent> {
    constructor() {
        super("nds.event.NdsEvent", [
            { no: 1, name: "id", kind: "message", T: () => EventId },
            { no: 2, name: "occurred_at", kind: "message", T: () => Timestamp },
            { no: 3, name: "actor", kind: "message", T: () => NdsIdentity },
            { no: 4, name: "type", kind: "enum", T: () => ["nds.event.EventType", EventType, "EVENT_TYPE_"] },
            { no: 5, name: "payload", kind: "message", T: () => NdsPayload },
            { no: 6, name: "schema_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "context", kind: "message", T: () => NdsContext }
        ]);
    }
    create(value?: PartialMessage<NdsEvent>): NdsEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.schemaVersion = 0;
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<NdsEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NdsEvent): NdsEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nds.event.EventId id */ 1:
                    message.id = EventId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* google.protobuf.Timestamp occurred_at */ 2:
                    message.occurredAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.occurredAt);
                    break;
                case /* nds.identity.NdsIdentity actor */ 3:
                    message.actor = NdsIdentity.internalBinaryRead(reader, reader.uint32(), options, message.actor);
                    break;
                case /* nds.event.EventType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* nds.event.NdsPayload payload */ 5:
                    message.payload = NdsPayload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* int32 schema_version */ 6:
                    message.schemaVersion = reader.int32();
                    break;
                case /* map<string, string> metadata */ 7:
                    this.binaryReadMap7(message.metadata, reader, options);
                    break;
                case /* optional nds.context.NdsContext context */ 8:
                    message.context = NdsContext.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: NdsEvent["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NdsEvent["metadata"] | undefined, val: NdsEvent["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for nds.event.NdsEvent.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: NdsEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nds.event.EventId id = 1; */
        if (message.id)
            EventId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp occurred_at = 2; */
        if (message.occurredAt)
            Timestamp.internalBinaryWrite(message.occurredAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* nds.identity.NdsIdentity actor = 3; */
        if (message.actor)
            NdsIdentity.internalBinaryWrite(message.actor, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* nds.event.EventType type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* nds.event.NdsPayload payload = 5; */
        if (message.payload)
            NdsPayload.internalBinaryWrite(message.payload, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 schema_version = 6; */
        if (message.schemaVersion !== 0)
            writer.tag(6, WireType.Varint).int32(message.schemaVersion);
        /* map<string, string> metadata = 7; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* optional nds.context.NdsContext context = 8; */
        if (message.context)
            NdsContext.internalBinaryWrite(message.context, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.event.NdsEvent
 */
export const NdsEvent = new NdsEvent$Type();
