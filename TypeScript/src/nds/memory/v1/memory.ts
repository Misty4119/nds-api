// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "nds/memory/v1/memory.proto" (package "nds.memory.v1", syntax proto3)
// tslint:disable
//
// [Module] NDS Protocol
// [Component] memory.proto
// [Layer] Contract (language-agnostic)
// [Index] NDS-PROTO-MEMORY-V1-000
// [Semantic] v3+ memory-proof data structures (verifiable artifacts).
// [Since] 3.0.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PersonaId } from "../../identity/v1/identity_v1";
// ============================================================================
// [Index] NDS-PROTO-MEMORY-V1-010 Hash
// ============================================================================

/**
 * @generated from protobuf message nds.memory.v1.Hash
 */
export interface Hash {
    /**
     * [Example] "SHA-256"
     *
     * @generated from protobuf field: string algorithm = 1
     */
    algorithm: string;
    /**
     * @generated from protobuf field: bytes value = 2
     */
    value: Uint8Array;
}
// ============================================================================
// [Index] NDS-PROTO-MEMORY-V1-020 Proof
// ============================================================================

/**
 * [Semantic] Proof structure referencing ledger truth (tx/event ids) and anchoring hashes.
 *
 * @generated from protobuf message nds.memory.v1.MemoryProof
 */
export interface MemoryProof {
    /**
     * Link to ledger truth.
     *
     * @generated from protobuf field: optional bytes proof_tx_id = 1
     */
    proofTxId?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes proof_event_id = 2
     */
    proofEventId?: Uint8Array;
    /**
     * Verifiable content hash.
     *
     * @generated from protobuf field: nds.memory.v1.Hash content_hash = 10
     */
    contentHash?: Hash;
    /**
     * Either chain-style or batch-style anchoring (or both).
     *
     * @generated from protobuf field: optional nds.memory.v1.Hash prev_hash = 11
     */
    prevHash?: Hash;
    /**
     * @generated from protobuf field: optional nds.memory.v1.Hash merkle_root = 12
     */
    merkleRoot?: Hash;
}
// ============================================================================
// [Index] NDS-PROTO-MEMORY-V1-040 MemoryArtifact
// ============================================================================

/**
 * @generated from protobuf message nds.memory.v1.MemoryArtifact
 */
export interface MemoryArtifact {
    /**
     * @generated from protobuf field: bytes id = 1
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: nds.identity.v1.PersonaId owner = 2
     */
    owner?: PersonaId;
    /**
     * @generated from protobuf field: int32 schema_version = 3
     */
    schemaVersion: number;
    /**
     * Content. Governance MUST prevent secrets/PII from being stored here.
     *
     * @generated from protobuf field: optional string narrative = 10
     */
    narrative?: string;
    /**
     * Optional embedding vector (structure only; storage/indexing is implementation-defined).
     *
     * @generated from protobuf field: repeated float embedding = 11 [packed = true]
     */
    embedding: number[];
    /**
     * Proof structure.
     *
     * @generated from protobuf field: nds.memory.v1.MemoryProof proof = 20
     */
    proof?: MemoryProof;
    /**
     * Compliance: auditable redaction marker.
     *
     * @generated from protobuf field: bool redacted = 30
     */
    redacted: boolean;
    /**
     * @generated from protobuf field: optional nds.memory.v1.RedactionReason redaction_reason = 31
     */
    redactionReason?: RedactionReason;
}
// ============================================================================
// [Index] NDS-PROTO-MEMORY-V1-030 Redaction
// ============================================================================

/**
 * @generated from protobuf enum nds.memory.v1.RedactionReason
 */
export enum RedactionReason {
    /**
     * @generated from protobuf enum value: REDACTION_REASON_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: REDACTION_REASON_PRIVACY_REQUEST = 1;
     */
    PRIVACY_REQUEST = 1,
    /**
     * @generated from protobuf enum value: REDACTION_REASON_POLICY = 2;
     */
    POLICY = 2,
    /**
     * @generated from protobuf enum value: REDACTION_REASON_LEGAL = 3;
     */
    LEGAL = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Hash$Type extends MessageType<Hash> {
    constructor() {
        super("nds.memory.v1.Hash", [
            { no: 1, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Hash>): Hash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.algorithm = "";
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Hash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hash): Hash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string algorithm */ 1:
                    message.algorithm = reader.string();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Hash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string algorithm = 1; */
        if (message.algorithm !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.algorithm);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.memory.v1.Hash
 */
export const Hash = new Hash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemoryProof$Type extends MessageType<MemoryProof> {
    constructor() {
        super("nds.memory.v1.MemoryProof", [
            { no: 1, name: "proof_tx_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "proof_event_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "content_hash", kind: "message", T: () => Hash },
            { no: 11, name: "prev_hash", kind: "message", T: () => Hash },
            { no: 12, name: "merkle_root", kind: "message", T: () => Hash }
        ]);
    }
    create(value?: PartialMessage<MemoryProof>): MemoryProof {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MemoryProof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemoryProof): MemoryProof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes proof_tx_id */ 1:
                    message.proofTxId = reader.bytes();
                    break;
                case /* optional bytes proof_event_id */ 2:
                    message.proofEventId = reader.bytes();
                    break;
                case /* nds.memory.v1.Hash content_hash */ 10:
                    message.contentHash = Hash.internalBinaryRead(reader, reader.uint32(), options, message.contentHash);
                    break;
                case /* optional nds.memory.v1.Hash prev_hash */ 11:
                    message.prevHash = Hash.internalBinaryRead(reader, reader.uint32(), options, message.prevHash);
                    break;
                case /* optional nds.memory.v1.Hash merkle_root */ 12:
                    message.merkleRoot = Hash.internalBinaryRead(reader, reader.uint32(), options, message.merkleRoot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemoryProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes proof_tx_id = 1; */
        if (message.proofTxId !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.proofTxId);
        /* optional bytes proof_event_id = 2; */
        if (message.proofEventId !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proofEventId);
        /* nds.memory.v1.Hash content_hash = 10; */
        if (message.contentHash)
            Hash.internalBinaryWrite(message.contentHash, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.memory.v1.Hash prev_hash = 11; */
        if (message.prevHash)
            Hash.internalBinaryWrite(message.prevHash, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional nds.memory.v1.Hash merkle_root = 12; */
        if (message.merkleRoot)
            Hash.internalBinaryWrite(message.merkleRoot, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.memory.v1.MemoryProof
 */
export const MemoryProof = new MemoryProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemoryArtifact$Type extends MessageType<MemoryArtifact> {
    constructor() {
        super("nds.memory.v1.MemoryArtifact", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "owner", kind: "message", T: () => PersonaId },
            { no: 3, name: "schema_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "narrative", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "embedding", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "proof", kind: "message", T: () => MemoryProof },
            { no: 30, name: "redacted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "redaction_reason", kind: "enum", opt: true, T: () => ["nds.memory.v1.RedactionReason", RedactionReason, "REDACTION_REASON_"] }
        ]);
    }
    create(value?: PartialMessage<MemoryArtifact>): MemoryArtifact {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = new Uint8Array(0);
        message.schemaVersion = 0;
        message.embedding = [];
        message.redacted = false;
        if (value !== undefined)
            reflectionMergePartial<MemoryArtifact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemoryArtifact): MemoryArtifact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* nds.identity.v1.PersonaId owner */ 2:
                    message.owner = PersonaId.internalBinaryRead(reader, reader.uint32(), options, message.owner);
                    break;
                case /* int32 schema_version */ 3:
                    message.schemaVersion = reader.int32();
                    break;
                case /* optional string narrative */ 10:
                    message.narrative = reader.string();
                    break;
                case /* repeated float embedding = 11 [packed = true] */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.embedding.push(reader.float());
                    else
                        message.embedding.push(reader.float());
                    break;
                case /* nds.memory.v1.MemoryProof proof */ 20:
                    message.proof = MemoryProof.internalBinaryRead(reader, reader.uint32(), options, message.proof);
                    break;
                case /* bool redacted */ 30:
                    message.redacted = reader.bool();
                    break;
                case /* optional nds.memory.v1.RedactionReason redaction_reason */ 31:
                    message.redactionReason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemoryArtifact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* nds.identity.v1.PersonaId owner = 2; */
        if (message.owner)
            PersonaId.internalBinaryWrite(message.owner, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 schema_version = 3; */
        if (message.schemaVersion !== 0)
            writer.tag(3, WireType.Varint).int32(message.schemaVersion);
        /* optional string narrative = 10; */
        if (message.narrative !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.narrative);
        /* repeated float embedding = 11 [packed = true]; */
        if (message.embedding.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.embedding.length; i++)
                writer.float(message.embedding[i]);
            writer.join();
        }
        /* nds.memory.v1.MemoryProof proof = 20; */
        if (message.proof)
            MemoryProof.internalBinaryWrite(message.proof, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* bool redacted = 30; */
        if (message.redacted !== false)
            writer.tag(30, WireType.Varint).bool(message.redacted);
        /* optional nds.memory.v1.RedactionReason redaction_reason = 31; */
        if (message.redactionReason !== undefined)
            writer.tag(31, WireType.Varint).int32(message.redactionReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nds.memory.v1.MemoryArtifact
 */
export const MemoryArtifact = new MemoryArtifact$Type();
