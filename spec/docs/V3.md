# NDS Protocol (versioned packages)
# Index: `spec/docs/README.md`

## Scope

This document defines **v3+ protocol semantics** for the versioned packages under:

- `spec/proto/nds/**/v1/*.proto`

This is a **contract** document only. It does not require any specific runtime, storage, or transport.

## Non-negotiables

- **Additive-only** evolution for published protos:
  - Never renumber fields.
  - Never change meaning/units of existing fields.
- **Deterministic economic numerics**:
  - Java MUST use `BigDecimal`.
  - C# MUST use `decimal`.
  - Proto v2 uses `nds.common.Decimal` (string-based).
  - Proto v3 hot-path MAY use fixed-point `nds.ledger.v1.Money` and MUST be convertible deterministically.
- **No secrets**: never put tokens/keys/passwords/PII into proto fields, docs, or examples.
- **No runtime dependencies**: `nds-api` remains platform-agnostic.

## File targets

- Proto:
  - `spec/proto/nds/ledger/v1/ledger.proto`
  - `spec/proto/nds/sync/v1/sync.proto`
  - `spec/proto/nds/common/v1/common_v1.proto`
  - `spec/proto/nds/event/v1/event_v1.proto`
  - `spec/proto/nds/identity/v1/identity_v1.proto`
  - `spec/proto/nds/metadata/v1/metadata.proto`
  - `spec/proto/nds/memory/v1/memory.proto`
- SDK adapters (normative behavior):
  - `java/src/main/java/noie/linmimeng/noiedigitalsystem/api/adapter/**`
  - `csharp/src/Noie.Nds.Api/Adapter/**`

## Commands

```bash
cd spec/proto
buf lint
```

## Money (fixed-point) — invariants and normalization

This section is **normative** for `nds.ledger.v1.Money`.

### Representation

`Money` represents an exact amount:

\[
\text{amount} = units + \frac{nanos}{10^9}
\]

where `units` is an `int64` and `nanos` is an `int32`.

### Invariants (MUST)

- **Range**: \(0 \le |nanos| < 1{,}000{,}000{,}000\)
- **Zero**: if the numeric amount is exactly zero, then `units = 0` and `nanos = 0`
- **Currency**: `currency_code` MUST be non-empty (registry/validation is implementation-defined)
- **Canonicalization**: producers SHOULD emit canonical values:
  - `nanos = 0` when the value has no fractional part
  - values MUST NOT rely on ambiguous sign encodings

### Sign rule (MUST)

For non-zero values, `units` and `nanos` MUST be **consistent with the numeric sign** of the amount:

- If the amount is positive:
  - `units > 0` OR (`units = 0` and `nanos > 0`)
- If the amount is negative:
  - `units < 0` OR (`units = 0` and `nanos < 0`)

The following example is **forbidden** because it is ambiguous across languages:

- `units = -1`, `nanos = +500_000_000`

### Conversion to/from precise decimals (normative)

The canonical scale for `Money` is **9 fractional digits** (nanos).

#### To Money (exact; no rounding)

SDKs MUST provide an **exact** conversion:

- Input has more than 9 fractional digits **after removing trailing zeros** → MUST fail (throw or return a failure result).
- Otherwise, the value MUST be represented exactly by `(units, nanos)` without rounding.

#### From Money (exact)

SDKs MUST convert `(units, nanos)` back to a precise decimal exactly:

- `amount = units + nanos / 10^9`
- `nanos` MUST be validated against the range invariant.

## Correctness semantics (v3+)

### Idempotency (MUST)

For any request that changes ledger state, clients MUST supply `RequestContext.idempotency_key`, and servers MUST define:

- **Scope**: what the key is scoped to (at minimum: actor + operation type)
- **Retention**: how long keys are retained (e.g. 24h / 7d)
- **Replay behavior**: retrying with the same key returns the same logical outcome (e.g. same `tx_id`)

### Retry taxonomy (normative)

`nds.common.v1.ErrorCategory` drives mechanical retry decisions:

- `ERROR_CATEGORY_RETRYABLE`: timeouts, temporary unavailability, overload/backpressure
- `ERROR_CATEGORY_CONFLICT`: optimistic concurrency conflicts (version mismatch)
- `ERROR_CATEGORY_POLICY`: business rule failures (insufficient funds, policy violation)
- `ERROR_CATEGORY_VALIDATION`: invalid arguments, malformed requests
- `ERROR_CATEGORY_FATAL`: unexpected failures (do not retry automatically)

### Concurrency control (CAS / expected_version) (MUST)

When a request updates shared state (e.g. balance or limits), the protocol MUST allow clients to express optimistic concurrency expectations.

Protocol mapping:

- `nds.ledger.v1.Balance.version` is the version token returned by the server.
- `nds.ledger.v1.CreateTransactionRequest.expected_source_version` / `expected_target_version` are used for CAS when a source/target is involved.

If the expected version does not match, servers SHOULD return:

- `ErrorStatus.code = "CONFLICT_VERSION_MISMATCH"`
- `ErrorStatus.category = ERROR_CATEGORY_CONFLICT`

## Streaming semantics (v3+)

This section is **normative** for subscribe/watch/replay/resume.

### Resume token (MUST)

- Resume MUST use a **server-issued** opaque token (`ResumeToken` / `Cursor`).
- Clients MUST NOT construct tokens.
- Servers MUST define replay retention and the error behavior when a token expires (e.g. explicit error code + fallback to `since`).

#### Resume token expiration (normative)

When a resume token cannot be honored, the server MUST return:

- `ErrorStatus.code = "SYNC_RESUME_TOKEN_EXPIRED"`
- `ErrorStatus.category = ERROR_CATEGORY_RETRYABLE`

The server MUST include machine-readable fallback hints in `ErrorStatus.details`:

- `fallback_strategy`: one of `since`, `full_snapshot`
- `fallback_since_unix_millis`: UTC milliseconds since epoch (required when `fallback_strategy=since`)
- `replay_window_seconds`: server replay retention window in seconds (optional)

### Ordering (MUST)

At least one ordering guarantee MUST be defined. Recommended options:

- **Total order** per stream (cursor is strictly increasing).
- **Partitioned order** per key (e.g. per `owner`), with no global total order.

Protocol mapping:

- `nds.sync.v1.OrderingMode` MUST be surfaced by implementations for each stream.

### Backpressure (MUST)

The protocol MUST allow clients to express rate limits (e.g. `max_events_per_second`).
Servers MAY treat these as hints, but MUST provide a deterministic error category when rejecting due to overload (RETRYABLE + optional `retry_after_seconds`).

Flow-control fields:

- `SubscribeEventsRequest.max_events_per_second` / `WatchBalanceRequest.max_updates_per_second`
- `SubscribeEventsRequest.max_in_flight` / `WatchBalanceRequest.max_in_flight`
- `SubscribeEventsRequest.page_size` (for batching-capable transports)

## Metadata extensions (limits and governance)

This section is **normative** for extension governance where `google.protobuf.Any` is used.

Implementations MUST define and enforce size limits to prevent unbounded payload growth.
Recommended defaults (may be tightened):

- Maximum size per single extension payload: **8 KiB**
- Maximum total extension payload per message: **64 KiB**

## Error codes (recommended minimal set)

This section is **normative** for the recommended `ErrorStatus.code` values for v3+.

Rules:

- Codes MUST be stable identifiers.
- Codes MUST be machine-actionable (paired with `ErrorCategory`).
- Codes MUST NOT embed PII or secret material.

Recommended codes:

- `VALIDATION_INVALID_ARGUMENT` (`ERROR_CATEGORY_VALIDATION`)
- `AUTH_PERMISSION_DENIED` (`ERROR_CATEGORY_FATAL` or `ERROR_CATEGORY_POLICY`, depending on policy model)
- `LEDGER_INSUFFICIENT_BALANCE` (`ERROR_CATEGORY_POLICY`)
- `LEDGER_CURRENCY_NOT_FOUND` (`ERROR_CATEGORY_VALIDATION`)
- `CONFLICT_VERSION_MISMATCH` (`ERROR_CATEGORY_CONFLICT`)
- `IDEMPOTENCY_REPLAYED` (category is implementation-defined; must not imply retry required)
- `SYNC_RESUME_TOKEN_EXPIRED` (`ERROR_CATEGORY_RETRYABLE`, MUST include a fallback hint in `details`)
- `SYSTEM_UNAVAILABLE` (`ERROR_CATEGORY_RETRYABLE`, SHOULD set `retry_after_seconds`)
- `SYSTEM_TIMEOUT` (`ERROR_CATEGORY_RETRYABLE`)

## Links

- `spec/docs/PROTOCOL.md` (v2 overview + module map)
