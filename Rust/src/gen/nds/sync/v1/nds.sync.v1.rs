// @generated
// This file is @generated by prost-build.
// ============================================================================
// \[Index\] NDS-PROTO-SYNC-V1-010 ResumeToken
// ============================================================================

/// \[Semantic\] Server-issued resume token for continuation.
/// \[Invariant\] Clients MUST treat this as opaque.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResumeToken {
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
// ============================================================================
// \[Index\] NDS-PROTO-SYNC-V1-020 SubscribeEvents
// ============================================================================

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeEventsRequest {
    /// Resume streaming from a previous position.
    #[prost(message, optional, tag="1")]
    pub resume: ::core::option::Option<ResumeToken>,
    /// Fallback start time (UTC). Used when resume is absent/expired.
    #[prost(message, optional, tag="2")]
    pub since: ::core::option::Option<::prost_types::Timestamp>,
    /// Filter by event types.
    #[prost(enumeration="super::super::event::v1::EventType", repeated, tag="3")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// Filter by owner persona.
    #[prost(message, optional, tag="4")]
    pub owner: ::core::option::Option<super::super::identity::v1::PersonaId>,
    /// Flow control hint (best-effort).
    #[prost(int32, tag="10")]
    pub max_events_per_second: i32,
    /// Flow control hint: maximum number of in-flight messages the client can process.
    #[prost(int32, optional, tag="11")]
    pub max_in_flight: ::core::option::Option<i32>,
    /// Flow control hint: preferred batch/page size (for transports that support batching).
    #[prost(int32, optional, tag="12")]
    pub page_size: ::core::option::Option<i32>,
}
/// \[Semantic\] Subscribe response envelope for streaming transports.
/// \[Note\] This is a shape definition; transports (gRPC/WebSocket/etc.) are implementation-defined.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeEventsResponse {
    /// Server-issued resume token representing the last delivered position.
    /// Implementations SHOULD update this as events are delivered.
    #[prost(message, optional, tag="1")]
    pub resume: ::core::option::Option<ResumeToken>,
    /// Ordering guarantee of this stream.
    #[prost(enumeration="OrderingMode", optional, tag="2")]
    pub ordering: ::core::option::Option<i32>,
    #[prost(oneof="subscribe_events_response::Message", tags="10, 11, 12")]
    pub message: ::core::option::Option<subscribe_events_response::Message>,
}
/// Nested message and enum types in `SubscribeEventsResponse`.
pub mod subscribe_events_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// A single event delivery.
        #[prost(message, tag="10")]
        Event(super::super::super::event::v1::EventEnvelope),
        /// A non-fatal heartbeat to keep the stream alive.
        #[prost(message, tag="11")]
        Heartbeat(super::Heartbeat),
        /// Terminal or retryable error. See nds.common.v1.ErrorCategory for retry decisions.
        #[prost(message, tag="12")]
        Error(super::super::super::common::v1::ErrorStatus),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Heartbeat {
    /// Server time (UTC) when heartbeat was emitted.
    #[prost(message, optional, tag="1")]
    pub at: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================================================
// \[Index\] NDS-PROTO-SYNC-V1-030 WatchBalance
// ============================================================================

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchBalanceRequest {
    #[prost(message, optional, tag="1")]
    pub key: ::core::option::Option<super::super::ledger::v1::BalanceKey>,
    #[prost(message, optional, tag="2")]
    pub resume: ::core::option::Option<ResumeToken>,
    /// Flow control hint (best-effort).
    #[prost(int32, tag="10")]
    pub max_updates_per_second: i32,
    #[prost(int32, optional, tag="11")]
    pub max_in_flight: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BalanceSnapshot {
    #[prost(message, optional, tag="1")]
    pub balance: ::core::option::Option<super::super::ledger::v1::Balance>,
    #[prost(message, optional, tag="2")]
    pub cursor: ::core::option::Option<super::super::event::v1::Cursor>,
}
/// \[Semantic\] Delta update (preferred over full-state push).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BalanceDelta {
    #[prost(message, optional, tag="1")]
    pub key: ::core::option::Option<super::super::ledger::v1::BalanceKey>,
    #[prost(message, optional, tag="2")]
    pub delta: ::core::option::Option<super::super::ledger::v1::Money>,
    #[prost(uint64, tag="3")]
    pub new_version: u64,
    #[prost(message, optional, tag="4")]
    pub cursor: ::core::option::Option<super::super::event::v1::Cursor>,
    /// Proof link to the committed transaction.
    #[prost(bytes="vec", tag="5")]
    pub proof_tx_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional proof link to the committed event (if event id differs from tx id).
    #[prost(bytes="vec", optional, tag="6")]
    pub proof_event_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// \[Semantic\] Watch response envelope for streaming transports.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchBalanceResponse {
    #[prost(message, optional, tag="1")]
    pub resume: ::core::option::Option<ResumeToken>,
    #[prost(enumeration="OrderingMode", optional, tag="2")]
    pub ordering: ::core::option::Option<i32>,
    #[prost(oneof="watch_balance_response::Message", tags="10, 11, 12, 13")]
    pub message: ::core::option::Option<watch_balance_response::Message>,
}
/// Nested message and enum types in `WatchBalanceResponse`.
pub mod watch_balance_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag="10")]
        Snapshot(super::BalanceSnapshot),
        #[prost(message, tag="11")]
        Delta(super::BalanceDelta),
        #[prost(message, tag="12")]
        Error(super::super::super::common::v1::ErrorStatus),
        #[prost(message, tag="13")]
        Heartbeat(super::Heartbeat),
    }
}
// ============================================================================
// \[Index\] NDS-PROTO-SYNC-V1-015 OrderingMode
// ============================================================================

/// \[Semantic\] Declares the ordering guarantee of a stream.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderingMode {
    Unspecified = 0,
    /// A single stream has a total order; cursor is monotonically increasing.
    Total = 1,
    /// Ordering is guaranteed only within a partition (e.g. per owner/key).
    Partitioned = 2,
}
impl OrderingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDERING_MODE_UNSPECIFIED",
            Self::Total => "ORDERING_MODE_TOTAL",
            Self::Partitioned => "ORDERING_MODE_PARTITIONED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDERING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDERING_MODE_TOTAL" => Some(Self::Total),
            "ORDERING_MODE_PARTITIONED" => Some(Self::Partitioned),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
