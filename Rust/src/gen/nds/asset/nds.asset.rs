// @generated
// This file is @generated by prost-build.
// ============================================================================
// \[Index\] NDS-PROTO-ASSET-020 AssetId
// ============================================================================

/// \[Semantic\] Globally unique asset identifier.
/// \[Behavior\] Canonical string form: "scope:name" (e.g. "player:coins", "server:world_boss_hp").
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetId {
    /// Asset name (e.g. "coins", "gold", "world_boss_hp").
    /// Naming rule: lowercase letters + underscores only.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Asset scope.
    #[prost(enumeration="AssetScope", tag="2")]
    pub scope: i32,
}
// ============================================================================
// \[Index\] NDS-PROTO-ASSET-030 NdsAsset
// ============================================================================

/// \[Semantic\] Asset definition (metadata/tags/limits) without balances.
/// \[Behavior\] Balances are derived from transactions and projections.
/// \[SearchTag\] asset, metadata, tags, limit
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NdsAsset {
    /// Asset ID.
    #[prost(message, optional, tag="1")]
    pub asset_id: ::core::option::Option<AssetId>,
    /// Tags for semantic queries / UI categorization / vectorization.
    /// Example: {"category": "currency", "rarity": "common", "tradable": "true"}
    #[prost(map="string, string", tag="2")]
    pub tags: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Metadata (e.g. display name, icon URL, description).
    #[prost(map="string, string", tag="3")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Optional limit (maximum allowed value).
    #[prost(message, optional, tag="4")]
    pub limit: ::core::option::Option<super::common::Decimal>,
    /// Created at (Unix epoch milliseconds).
    #[prost(int64, tag="5")]
    pub created_at: i64,
    /// Updated at (Unix epoch milliseconds).
    #[prost(int64, tag="6")]
    pub updated_at: i64,
}
// ============================================================================
// \[Index\] NDS-PROTO-ASSET-010 AssetScope
// ============================================================================

/// \[Semantic\] Scope of an asset.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetScope {
    /// Unknown scope (default; for backward compatibility).
    Unspecified = 0,
    /// Player scope (belongs to a specific player).
    Player = 1,
    /// Server scope (belongs to a server instance).
    Server = 2,
    /// Global scope (belongs to the whole system).
    Global = 3,
}
impl AssetScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ASSET_SCOPE_UNSPECIFIED",
            Self::Player => "ASSET_SCOPE_PLAYER",
            Self::Server => "ASSET_SCOPE_SERVER",
            Self::Global => "ASSET_SCOPE_GLOBAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSET_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ASSET_SCOPE_PLAYER" => Some(Self::Player),
            "ASSET_SCOPE_SERVER" => Some(Self::Server),
            "ASSET_SCOPE_GLOBAL" => Some(Self::Global),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
