// @generated
// This file is @generated by prost-build.
// ============================================================================
// \[Index\] NDS-PROTO-MEMORY-V1-010 Hash
// ============================================================================

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Hash {
    /// \[Example\] "SHA-256"
    #[prost(string, tag="1")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
// ============================================================================
// \[Index\] NDS-PROTO-MEMORY-V1-020 Proof
// ============================================================================

/// \[Semantic\] Proof structure referencing ledger truth (tx/event ids) and anchoring hashes.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MemoryProof {
    /// Link to ledger truth.
    #[prost(bytes="vec", optional, tag="1")]
    pub proof_tx_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="2")]
    pub proof_event_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Verifiable content hash.
    #[prost(message, optional, tag="10")]
    pub content_hash: ::core::option::Option<Hash>,
    /// Either chain-style or batch-style anchoring (or both).
    #[prost(message, optional, tag="11")]
    pub prev_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="12")]
    pub merkle_root: ::core::option::Option<Hash>,
}
// ============================================================================
// \[Index\] NDS-PROTO-MEMORY-V1-040 MemoryArtifact
// ============================================================================

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryArtifact {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="2")]
    pub owner: ::core::option::Option<super::super::identity::v1::PersonaId>,
    #[prost(int32, tag="3")]
    pub schema_version: i32,
    /// Content. Governance MUST prevent secrets/PII from being stored here.
    #[prost(string, optional, tag="10")]
    pub narrative: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional embedding vector (structure only; storage/indexing is implementation-defined).
    #[prost(float, repeated, tag="11")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    /// Proof structure.
    #[prost(message, optional, tag="20")]
    pub proof: ::core::option::Option<MemoryProof>,
    /// Compliance: auditable redaction marker.
    #[prost(bool, tag="30")]
    pub redacted: bool,
    #[prost(enumeration="RedactionReason", optional, tag="31")]
    pub redaction_reason: ::core::option::Option<i32>,
}
// ============================================================================
// \[Index\] NDS-PROTO-MEMORY-V1-030 Redaction
// ============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RedactionReason {
    Unspecified = 0,
    PrivacyRequest = 1,
    Policy = 2,
    Legal = 3,
}
impl RedactionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REDACTION_REASON_UNSPECIFIED",
            Self::PrivacyRequest => "REDACTION_REASON_PRIVACY_REQUEST",
            Self::Policy => "REDACTION_REASON_POLICY",
            Self::Legal => "REDACTION_REASON_LEGAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REDACTION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "REDACTION_REASON_PRIVACY_REQUEST" => Some(Self::PrivacyRequest),
            "REDACTION_REASON_POLICY" => Some(Self::Policy),
            "REDACTION_REASON_LEGAL" => Some(Self::Legal),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
